<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Coffre & chiffreur de fichiers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --bg-panel: #0b1220;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --accent-strong: #6366f1;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --danger: #f97373;
      --radius: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: linear-gradient(145deg, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
      border-radius: 24px;
      box-shadow:
        0 24px 80px rgba(15,23,42,0.9),
        0 0 0 1px rgba(148,163,184,0.15);
      padding: 18px 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    @media (min-width: 900px) {
      .app {
        padding: 22px 22px 24px;
        gap: 18px;
      }
    }

    .header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    h1 {
      font-size: 1.4rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-soft);
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--text-soft);
      max-width: 620px;
    }

    .top-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .settings-btn {
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      padding: 6px 10px;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, transform 0.1s ease;
    }

    .settings-btn:hover {
      background: rgba(15,23,42,1);
      border-color: var(--accent);
      color: var(--text);
      transform: translateY(-1px);
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      padding: 4px;
      border: 1px solid rgba(30,64,175,0.7);
    }

    .tab-btn {
      border-radius: 999px;
      border: none;
      padding: 6px 14px;
      font-size: 0.82rem;
      cursor: pointer;
      background: transparent;
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, color 0.15s ease, transform 0.1s ease;
    }

    .tab-btn span.icon {
      font-size: 0.9rem;
    }

    .tab-btn.active {
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #0b1120;
      transform: translateY(-1px);
    }

    .tab-btn:not(.active):hover {
      color: var(--text);
      transform: translateY(-1px);
    }

    .main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    @media (min-width: 900px) {
      .main {
        grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr);
        gap: 16px;
      }
    }

    .panel {
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(129,140,248,0.12), transparent 55%),
                  var(--bg-panel);
      border-radius: var(--radius);
      padding: 14px 14px 16px;
      border: 1px solid rgba(148,163,184,0.25);
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    @media (min-width: 900px) {
      .panel {
        padding: 16px 16px 18px;
      }
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(56,189,248,0.12), transparent 60%);
      opacity: 0.4;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .panel-inner {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-title {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .panel-subtitle {
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .dropzone {
      border-radius: 14px;
      border: 1px dashed rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.85);
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease, transform 0.12s ease;
    }

    .dropzone:hover {
      border-color: var(--accent);
      background: rgba(15,23,42,0.95);
      transform: translateY(-1px);
    }

    .dropzone.dragover {
      border-color: var(--accent);
      background: rgba(15,23,42,1);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.4);
    }

    .drop-main {
      font-size: 0.9rem;
    }

    .drop-main span {
      color: var(--accent);
      font-weight: 500;
    }

    .drop-sub {
      font-size: 0.78rem;
      color: var(--text-soft);
    }

    .file-input {
      display: none;
    }

    .file-info {
      font-size: 0.8rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .file-name {
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-size {
      opacity: 0.8;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .field-label {
      font-size: 0.8rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .field-label span {
      font-size: 0.7rem;
      opacity: 0.8;
    }

    .input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.9);
      color: var(--text);
      padding: 8px 12px;
      font-size: 0.85rem;
      outline: none;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    .input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.4);
      background: rgba(15,23,42,1);
    }

    .input::placeholder {
      color: rgba(148,163,184,0.8);
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.18s ease, opacity 0.12s ease;
      white-space: nowrap;
    }

    .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      color: #0b1120;
      box-shadow:
        0 10px 30px rgba(56,189,248,0.45),
        0 0 0 1px rgba(15,23,42,0.9);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow:
        0 14px 40px rgba(56,189,248,0.55),
        0 0 0 1px rgba(15,23,42,0.9);
    }

    .btn-primary:active {
      transform: translateY(0);
      box-shadow:
        0 6px 18px rgba(56,189,248,0.4),
        0 0 0 1px rgba(15,23,42,0.9);
    }

    .btn-ghost {
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      border: 1px solid rgba(148,163,184,0.5);
    }

    .btn-ghost:hover {
      background: rgba(15,23,42,1);
      color: var(--text);
    }

    .btn-danger {
      background: rgba(127,29,29,0.9);
      color: #fee2e2;
      border: 1px solid rgba(248,113,113,0.7);
    }

    .btn-danger:hover {
      background: rgba(153,27,27,1);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    .status {
      font-size: 0.78rem;
      color: var(--text-soft);
      min-height: 1.1em;
    }

    .status.error {
      color: var(--danger);
    }

    .status.success {
      color: #4ade80;
    }

    .progress-wrap {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      overflow: hidden;
      border: 1px solid rgba(30,64,175,0.8);
    }

    .progress-inner {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, #38bdf8, #6366f1);
      transition: width 0.15s ease;
    }

    .progress-label {
      font-size: 0.75rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.7rem;
    }

    .chip {
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.4);
      color: var(--text-soft);
    }

    .chip-accent {
      border-color: rgba(56,189,248,0.7);
      color: var(--accent);
      background: var(--accent-soft);
    }

    .meta {
      font-size: 0.78rem;
      color: var(--text-soft);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .meta-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .meta-key {
      opacity: 0.8;
    }

    .meta-value {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
      color: #e0f2fe;
    }

    .footer {
      font-size: 0.72rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      border-top: 1px solid rgba(30,64,175,0.6);
      padding-top: 8px;
      margin-top: 4px;
    }

    .footer span {
      opacity: 0.9;
    }

    .footer strong {
      font-weight: 600;
      color: #e0f2fe;
    }

    /* Coffre-fort */

    .vault-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 260px;
      overflow: auto;
      padding-right: 4px;
    }

    .vault-empty {
      font-size: 0.8rem;
      color: var(--text-soft);
      opacity: 0.9;
    }

    .vault-item {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
      padding: 6px 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.78rem;
    }

    .vault-item-header {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .vault-item-name {
      font-weight: 500;
      max-width: 260px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .vault-item-meta {
      color: var(--text-soft);
      font-size: 0.72rem;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .vault-item-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .vault-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-soft);
    }

    .vault-master-info {
      font-size: 0.78rem;
      color: var(--text-soft);
    }

    .vault-master-warning {
      font-size: 0.78rem;
      color: #facc15;
    }

    .hidden {
      display: none !important;
    }

    /* Modale param√®tres */

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal {
      width: 100%;
      max-width: 520px;
      background: #020617;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.5);
      box-shadow:
        0 24px 80px rgba(15,23,42,0.9),
        0 0 0 1px rgba(15,23,42,0.9);
      padding: 14px 16px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .modal-title {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .modal-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      margin-top: 4px;
    }

    .modal-section {
      border-radius: 12px;
      border: 1px solid rgba(30,64,175,0.7);
      background: rgba(15,23,42,0.9);
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.8rem;
    }

    .modal-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .modal-label {
      color: var(--text-soft);
      font-size: 0.78rem;
    }

    .modal-value {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
      color: #e0f2fe;
    }

    .toggle {
      position: relative;
      width: 38px;
      height: 20px;
      border-radius: 999px;
      background: rgba(15,23,42,1);
      border: 1px solid rgba(148,163,184,0.7);
      cursor: pointer;
      flex-shrink: 0;
    }

    .toggle-thumb {
      position: absolute;
      top: 1px;
      left: 1px;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: #e5e7eb;
      transition: transform 0.15s ease, background 0.15s ease;
    }

    .toggle.on {
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      border-color: transparent;
    }

    .toggle.on .toggle-thumb {
      transform: translateX(16px);
      background: #0b1120;
    }

    .preview-frame {
      border-radius: 10px;
      border: 1px solid rgba(30,64,175,0.7);
      background: rgba(15,23,42,0.9);
      padding: 6px;
      max-height: 220px;
      overflow: auto;
      font-size: 0.8rem;
    }

    .preview-frame img,
    .preview-frame video {
      max-width: 100%;
      border-radius: 8px;
    }

    .preview-placeholder {
      font-size: 0.78rem;
      color: var(--text-soft);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div class="title-row">
        <div>
          <h1>
            üîê Coffre & chiffreur
            <span class="badge">Client‚Äëside ‚Ä¢ Aucune donn√©e envoy√©e</span>
          </h1>
          <p class="subtitle">
            Chiffre, d√©chiffre et stocke des fichiers sensibles dans un coffre‚Äëfort local, prot√©g√© par un mot de passe ma√Ætre.
          </p>
        </div>
        <div class="top-right">
          <button class="settings-btn" id="settingsBtn">
            ‚öôÔ∏è Param√®tres
          </button>
        </div>
      </div>
      <div class="tabs">
        <button class="tab-btn active" data-tab="encrypt">
          <span class="icon">üß©</span> Chiffrer
        </button>
        <button class="tab-btn" data-tab="decrypt">
          <span class="icon">üîì</span> D√©chiffrer
        </button>
        <button class="tab-btn" data-tab="vault">
          <span class="icon">üóÑÔ∏è</span> Coffre‚Äëfort
        </button>
      </div>
    </header>

    <main class="main">
      <!-- Colonne gauche : contenu principal selon l‚Äôonglet -->
      <section class="panel">
        <div class="panel-inner" id="panelEncrypt">
          <div class="panel-title">
            <span>Chiffrer un fichier</span>
            <span class="panel-subtitle">Cr√©e une copie chiffr√©e (.encrypted) √† partir d‚Äôun fichier existant.</span>
          </div>

          <label class="dropzone" id="dropzoneEncrypt">
            <input type="file" id="fileInputEncrypt" class="file-input" />
            <div class="drop-main">
              <span>Cliquer pour choisir</span> ou d√©poser un fichier ici
            </div>
            <div class="drop-sub">
              Tous types accept√©s (mp4, jpg, pdf, docx, zip, etc.)
            </div>
          </label>

          <div class="file-info" id="fileInfoEncrypt" style="display:none;">
            <div class="file-name" id="fileNameEncrypt"></div>
            <div class="file-size" id="fileSizeEncrypt"></div>
          </div>

          <div class="field">
            <div class="field-label">
              Mot de passe
              <span>Servira √† d√©chiffrer plus tard</span>
            </div>
            <input
              type="password"
              id="passwordEncrypt"
              class="input"
              placeholder="Choisis un mot de passe solide"
              autocomplete="new-password"
            />
          </div>

          <div class="actions">
            <button type="button" class="btn btn-ghost" id="clearEncrypt">
              R√©initialiser
            </button>
            <button type="button" class="btn btn-primary" id="encryptBtn">
              Chiffrer &amp; t√©l√©charger
            </button>
          </div>

          <div class="status" id="statusEncrypt"></div>
        </div>

        <div class="panel-inner hidden" id="panelDecrypt">
          <div class="panel-title">
            <span>D√©chiffrer un fichier</span>
            <span class="panel-subtitle">Restaure un fichier original √† partir d‚Äôun .encrypted.</span>
          </div>

          <label class="dropzone" id="dropzoneDecrypt">
            <input type="file" id="fileInputDecrypt" class="file-input" />
            <div class="drop-main">
              <span>Cliquer pour choisir</span> ou d√©poser un fichier .encrypted ici
            </div>
            <div class="drop-sub">
              Utilise le m√™me mot de passe que lors du chiffrement.
            </div>
          </label>

          <div class="file-info" id="fileInfoDecrypt" style="display:none;">
            <div class="file-name" id="fileNameDecrypt"></div>
            <div class="file-size" id="fileSizeDecrypt"></div>
          </div>

          <div class="field">
            <div class="field-label">
              Mot de passe
              <span>Doit √™tre identique √† celui du chiffrement</span>
            </div>
            <input
              type="password"
              id="passwordDecrypt"
              class="input"
              placeholder="Entre le mot de passe utilis√©"
              autocomplete="current-password"
            />
          </div>

          <div class="actions">
            <button type="button" class="btn btn-ghost" id="clearDecrypt">
              R√©initialiser
            </button>
            <button type="button" class="btn btn-primary" id="decryptBtn">
              D√©chiffrer &amp; t√©l√©charger
            </button>
          </div>

          <div class="status" id="statusDecrypt"></div>
        </div>

        <div class="panel-inner hidden" id="panelVault">
          <div class="panel-title">
            <span>Coffre‚Äëfort</span>
            <span class="panel-subtitle">Stocke des fichiers chiffr√©s localement, accessibles 24h/24 sur ce navigateur.</span>
          </div>

          <div id="vaultIntro" class="vault-master-info">
            Premi√®re utilisation du coffre‚Äëfort : choisis un <strong>mot de passe ma√Ætre</strong>.  
            Il servira √† prot√©ger tous les fichiers stock√©s ici. Si tu le perds, les fichiers sont irr√©cup√©rables.
          </div>

          <div class="field" id="vaultMasterSetup">
            <div class="field-label">
              Mot de passe ma√Ætre du coffre
              <span>√Ä retenir absolument</span>
            </div>
            <input
              type="password"
              id="vaultMasterPassword"
              class="input"
              placeholder="Cr√©e un mot de passe ma√Ætre"
            />
            <input
              type="password"
              id="vaultMasterPasswordConfirm"
              class="input"
              placeholder="Confirme le mot de passe ma√Ætre"
            />
            <div class="actions">
              <button type="button" class="btn btn-primary" id="vaultMasterSetBtn">
                Initialiser le coffre‚Äëfort
              </button>
            </div>
          </div>

          <div id="vaultUnlockedSection" class="hidden">
            <div class="vault-master-info">
              Coffre‚Äëfort d√©verrouill√©. Tu peux ajouter des fichiers, les pr√©visualiser ou les restaurer.  
              <span class="vault-master-warning">Le mot de passe ma√Ætre n‚Äôest jamais stock√©. Tu devras le ressaisir √† chaque nouvelle visite.</span>
            </div>

            <label class="dropzone" id="dropzoneVault">
              <input type="file" id="fileInputVault" class="file-input" multiple />
              <div class="drop-main">
                <span>Cliquer pour ajouter</span> ou d√©poser des fichiers dans le coffre
              </div>
              <div class="drop-sub">
                Ils seront chiffr√©s et stock√©s localement dans ce navigateur.
              </div>
            </label>

            <div class="vault-list" id="vaultList">
              <div class="vault-empty" id="vaultEmpty">
                Aucun fichier dans le coffre pour l‚Äôinstant.
              </div>
            </div>
          </div>

          <div class="status" id="statusVault"></div>
        </div>
      </section>

      <!-- Colonne droite : progression + m√©tadonn√©es / aper√ßu -->
      <section class="panel">
        <div class="panel-inner" id="sideEncrypt">
          <div class="panel-title">
            <span>Progression &amp; d√©tails</span>
          </div>

          <div class="progress-wrap">
            <div class="progress-bar">
              <div class="progress-inner" id="progressEncrypt"></div>
            </div>
            <div class="progress-label">
              <span id="progressLabelEncrypt">En attente‚Ä¶</span>
              <span id="progressPercentEncrypt">0%</span>
            </div>
          </div>

          <div class="chip-row">
            <div class="chip chip-accent">AES‚ÄëGCM 256 bits</div>
            <div class="chip">Cl√© d√©riv√©e via PBKDF2</div>
            <div class="chip">Format : header JSON + sel + IV + donn√©es</div>
          </div>

          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Nom de sortie</span>
              <span class="meta-value" id="metaEncryptName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille chiffr√©e</span>
              <span class="meta-value" id="metaEncryptSize">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Sel &amp; IV</span>
              <span class="meta-value" id="metaEncryptSaltIv">‚Äî</span>
            </div>
          </div>
        </div>

        <div class="panel-inner hidden" id="sideDecrypt">
          <div class="panel-title">
            <span>Progression &amp; d√©tails</span>
          </div>

          <div class="progress-wrap">
            <div class="progress-bar">
              <div class="progress-inner" id="progressDecrypt"></div>
            </div>
            <div class="progress-label">
              <span id="progressLabelDecrypt">En attente‚Ä¶</span>
              <span id="progressPercentDecrypt">0%</span>
            </div>
          </div>

          <div class="chip-row">
            <div class="chip chip-accent">AES‚ÄëGCM 256 bits</div>
            <div class="chip">Lecture du header JSON</div>
            <div class="chip">Restauration du nom original</div>
          </div>

          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Nom restaur√©</span>
              <span class="meta-value" id="metaDecryptName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille d√©chiffr√©e</span>
              <span class="meta-value" id="metaDecryptSize">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Sel &amp; IV</span>
              <span class="meta-value" id="metaDecryptSaltIv">‚Äî</span>
            </div>
          </div>
        </div>

        <div class="panel-inner hidden" id="sideVault">
          <div class="panel-title">
            <span>Aper√ßu &amp; infos</span>
          </div>

          <div class="progress-wrap">
            <div class="progress-bar">
              <div class="progress-inner" id="progressVault"></div>
            </div>
            <div class="progress-label">
              <span id="progressLabelVault">En attente‚Ä¶</span>
              <span id="progressPercentVault">0%</span>
            </div>
          </div>

          <div class="chip-row">
            <div class="chip chip-accent">Coffre local (IndexedDB)</div>
            <div class="chip">Mot de passe ma√Ætre requis</div>
            <div class="chip">Rien n‚Äôest envoy√© sur Internet</div>
          </div>

          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Fichier s√©lectionn√©</span>
              <span class="meta-value" id="metaVaultName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille</span>
              <span class="meta-value" id="metaVaultSize">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Date d‚Äôajout</span>
              <span class="meta-value" id="metaVaultDate">‚Äî</span>
            </div>
          </div>

          <div class="preview-frame" id="vaultPreview">
            <div class="preview-placeholder">
              S√©lectionne un fichier dans le coffre pour tenter un aper√ßu (images, texte, PDF, vid√©o selon le navigateur).
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <span>Les fichiers originaux ne sont jamais modifi√©s, seules des copies chiffr√©es sont g√©n√©r√©es ou stock√©es.</span>
      <span><strong>Important :</strong> garde tes mots de passe. Sans eux, les fichiers sont d√©finitivement perdus.</span>
    </footer>
  </div>

  <!-- Modale param√®tres -->
  <div class="modal-backdrop hidden" id="settingsModalBackdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Param√®tres</div>
        <button class="btn btn-ghost" id="settingsCloseBtn">Fermer</button>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">Coffre‚Äëfort</div>
        <div class="modal-row">
          <div class="modal-label">Changer le mot de passe ma√Ætre</div>
          <button class="btn btn-ghost" id="changeMasterBtn">Changer‚Ä¶</button>
        </div>
        <div class="modal-row">
          <div class="modal-label">Effacer tout le coffre‚Äëfort</div>
          <button class="btn btn-danger" id="wipeVaultBtn">Vider le coffre</button>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">Interface</div>
        <div class="modal-row">
          <div class="modal-label">Animations l√©g√®res</div>
          <div class="toggle on" id="toggleAnimations">
            <div class="toggle-thumb"></div>
          </div>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">Technique</div>
        <div class="modal-row">
          <div class="modal-label">Espace utilis√© par le coffre</div>
          <div class="modal-value" id="vaultUsage">‚Äî</div>
        </div>
        <div class="modal-row">
          <div class="modal-label">Version du sch√©ma de chiffrement</div>
          <div class="modal-value">v1 ‚Ä¢ header JSON + sel + IV + donn√©es</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Helpers g√©n√©raux
    // =========================
    function formatBytes(bytes) {
      if (bytes === 0) return "0 o";
      const k = 1024;
      const sizes = ["o", "Ko", "Mo", "Go", "To"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    function setStatus(el, message, type = "") {
      el.textContent = message || "";
      el.className = "status" + (type ? " " + type : "");
    }

    function setProgress(bar, labelEl, percentEl, p, label) {
      const clamped = Math.max(0, Math.min(100, p));
      bar.style.width = clamped + "%";
      if (percentEl) percentEl.textContent = clamped.toFixed(0) + "%";
      if (label && labelEl) labelEl.textContent = label;
    }

    function toHex(arrBuf) {
      const bytes = new Uint8Array(arrBuf);
      return Array.from(bytes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
    }

    function concatBuffers(buffers) {
      let totalLength = 0;
      for (const b of buffers) totalLength += b.byteLength;
      const tmp = new Uint8Array(totalLength);
      let offset = 0;
      for (const b of buffers) {
        tmp.set(new Uint8Array(b), offset);
        offset += b.byteLength;
      }
      return tmp.buffer;
    }

    function stringToArrayBuffer(str) {
      return new TextEncoder().encode(str).buffer;
    }

    function arrayBufferToString(buf) {
      return new TextDecoder().decode(buf);
    }

    // =========================
    // Web Crypto helpers
    // =========================
    async function deriveKeyFromPassword(password, salt, iterations = 150000) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );

      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt,
          iterations,
          hash: "SHA-256",
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptWithPassword(password, dataBuffer, meta = {}) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKeyFromPassword(password, salt);

      const headerObj = {
        version: 1,
        meta,
      };
      const headerJson = JSON.stringify(headerObj);
      const headerBuf = stringToArrayBuffer(headerJson);
      const headerLen = new Uint32Array([headerBuf.byteLength]); // 4 octets

      const payload = concatBuffers([headerLen.buffer, headerBuf, dataBuffer]);

      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        payload
      );

      const finalBuffer = concatBuffers([salt.buffer, iv.buffer, encrypted]);
      return { finalBuffer, salt, iv };
    }

    async function decryptWithPassword(password, encryptedBuffer) {
      const salt = new Uint8Array(encryptedBuffer.slice(0, 16));
      const iv = new Uint8Array(encryptedBuffer.slice(16, 28));
      const cipherData = encryptedBuffer.slice(28);

      const key = await deriveKeyFromPassword(password, salt);

      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        cipherData
      );

      const view = new DataView(decrypted);
      const headerLen = view.getUint32(0, true);
      const headerBuf = decrypted.slice(4, 4 + headerLen);
      const dataBuf = decrypted.slice(4 + headerLen);

      const headerJson = arrayBufferToString(headerBuf);
      const headerObj = JSON.parse(headerJson);

      return {
        dataBuffer: dataBuf,
        header: headerObj,
        salt,
        iv,
      };
    }

    // =========================
    // Gestion des onglets
    // =========================
    const tabButtons = document.querySelectorAll(".tab-btn");
    const panelEncrypt = document.getElementById("panelEncrypt");
    const panelDecrypt = document.getElementById("panelDecrypt");
    const panelVault = document.getElementById("panelVault");
    const sideEncrypt = document.getElementById("sideEncrypt");
    const sideDecrypt = document.getElementById("sideDecrypt");
    const sideVault = document.getElementById("sideVault");

    function showTab(tab) {
      tabButtons.forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tab);
      });

      panelEncrypt.classList.toggle("hidden", tab !== "encrypt");
      panelDecrypt.classList.toggle("hidden", tab !== "decrypt");
      panelVault.classList.toggle("hidden", tab !== "vault");

      sideEncrypt.classList.toggle("hidden", tab !== "encrypt");
      sideDecrypt.classList.toggle("hidden", tab !== "decrypt");
      sideVault.classList.toggle("hidden", tab !== "vault");
    }

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.tab;
        showTab(tab);
        if (tab === "vault") {
          initVaultFlow();
        }
      });
    });

    // =========================
    // Chiffrement simple
    // =========================
    const fileInputEncrypt = document.getElementById("fileInputEncrypt");
    const dropzoneEncrypt = document.getElementById("dropzoneEncrypt");
    const fileInfoEncrypt = document.getElementById("fileInfoEncrypt");
    const fileNameEncrypt = document.getElementById("fileNameEncrypt");
    const fileSizeEncrypt = document.getElementById("fileSizeEncrypt");
    const passwordEncrypt = document.getElementById("passwordEncrypt");
    const encryptBtn = document.getElementById("encryptBtn");
    const clearEncrypt = document.getElementById("clearEncrypt");
    const statusEncrypt = document.getElementById("statusEncrypt");
    const progressEncrypt = document.getElementById("progressEncrypt");
    const progressLabelEncrypt = document.getElementById("progressLabelEncrypt");
    const progressPercentEncrypt = document.getElementById("progressPercentEncrypt");
    const metaEncryptName = document.getElementById("metaEncryptName");
    const metaEncryptSize = document.getElementById("metaEncryptSize");
    const metaEncryptSaltIv = document.getElementById("metaEncryptSaltIv");

    let selectedFileEncrypt = null;

    function resetEncrypt(full = false) {
      if (full) {
        selectedFileEncrypt = null;
        fileInputEncrypt.value = "";
        fileInfoEncrypt.style.display = "none";
        fileNameEncrypt.textContent = "";
        fileSizeEncrypt.textContent = "";
        passwordEncrypt.value = "";
        metaEncryptName.textContent = "‚Äî";
        metaEncryptSize.textContent = "‚Äî";
        metaEncryptSaltIv.textContent = "‚Äî";
      }
      setStatus(statusEncrypt, "");
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "En attente‚Ä¶");
    }

    function handleEncryptFile(file) {
      if (!file) return;
      selectedFileEncrypt = file;
      fileInfoEncrypt.style.display = "flex";
      fileNameEncrypt.textContent = file.name;
      fileSizeEncrypt.textContent = formatBytes(file.size);
      setStatus(statusEncrypt, "");
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "Fichier pr√™t √† √™tre chiffr√©");
    }

    dropzoneEncrypt.addEventListener("click", () => fileInputEncrypt.click());
    fileInputEncrypt.addEventListener("change", (e) => {
      const file = e.target.files[0];
      handleEncryptFile(file);
    });

    ["dragenter", "dragover"].forEach((eventName) => {
      dropzoneEncrypt.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneEncrypt.classList.add("dragover");
      });
    });

    ["dragleave", "drop"].forEach((eventName) => {
      dropzoneEncrypt.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneEncrypt.classList.remove("dragover");
      });
    });

    dropzoneEncrypt.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      const file = dt.files && dt.files[0];
      handleEncryptFile(file);
    });

    encryptBtn.addEventListener("click", async () => {
      if (!selectedFileEncrypt) {
        setStatus(statusEncrypt, "Choisis d‚Äôabord un fichier √† chiffrer.", "error");
        return;
      }
      const password = passwordEncrypt.value.trim();
      if (!password) {
        setStatus(statusEncrypt, "Entre un mot de passe pour chiffrer le fichier.", "error");
        return;
      }

      encryptBtn.disabled = true;
      clearEncrypt.disabled = true;
      setStatus(statusEncrypt, "");
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 5, "Initialisation‚Ä¶");

      try {
        setStatus(statusEncrypt, "Lecture du fichier‚Ä¶");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 15, "Lecture du fichier‚Ä¶");
        const arrayBuffer = await selectedFileEncrypt.arrayBuffer();

        setStatus(statusEncrypt, "Pr√©paration de la cl√©‚Ä¶");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 35, "D√©rivation de la cl√©‚Ä¶");

        const meta = {
          originalName: selectedFileEncrypt.name,
          originalSize: selectedFileEncrypt.size,
          mimeType: selectedFileEncrypt.type || "application/octet-stream",
          timestamp: Date.now(),
        };

        setStatus(statusEncrypt, "Chiffrement en cours‚Ä¶");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 65, "Chiffrement du contenu‚Ä¶");

        const { finalBuffer, salt, iv } = await encryptWithPassword(password, arrayBuffer, meta);

        setStatus(statusEncrypt, "Assemblage du fichier chiffr√©‚Ä¶");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 90, "Finalisation‚Ä¶");

        const outName = selectedFileEncrypt.name + ".encrypted";
        const blob = new Blob([finalBuffer], { type: "application/octet-stream" });

        metaEncryptName.textContent = outName;
        metaEncryptSize.textContent = formatBytes(blob.size);
        metaEncryptSaltIv.textContent = "salt=" + toHex(salt) + " ‚Ä¢ iv=" + toHex(iv);

        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 100, "Termin√©");
        setStatus(statusEncrypt, "Chiffrement termin√©. T√©l√©chargement de la copie chiffr√©e.", "success");

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = outName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        setStatus(statusEncrypt, "Erreur pendant le chiffrement.", "error");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "En attente‚Ä¶");
      } finally {
        encryptBtn.disabled = false;
        clearEncrypt.disabled = false;
      }
    });

    clearEncrypt.addEventListener("click", () => {
      resetEncrypt(true);
    });

    resetEncrypt(true);

    // =========================
    // D√©chiffrement simple
    // =========================
    const fileInputDecrypt = document.getElementById("fileInputDecrypt");
    const dropzoneDecrypt = document.getElementById("dropzoneDecrypt");
    const fileInfoDecrypt = document.getElementById("fileInfoDecrypt");
    const fileNameDecrypt = document.getElementById("fileNameDecrypt");
    const fileSizeDecrypt = document.getElementById("fileSizeDecrypt");
    const passwordDecrypt = document.getElementById("passwordDecrypt");
    const decryptBtn = document.getElementById("decryptBtn");
    const clearDecrypt = document.getElementById("clearDecrypt");
    const statusDecrypt = document.getElementById("statusDecrypt");
    const progressDecrypt = document.getElementById("progressDecrypt");
    const progressLabelDecrypt = document.getElementById("progressLabelDecrypt");
    const progressPercentDecrypt = document.getElementById("progressPercentDecrypt");
    const metaDecryptName = document.getElementById("metaDecryptName");
    const metaDecryptSize = document.getElementById("metaDecryptSize");
    const metaDecryptSaltIv = document.getElementById("metaDecryptSaltIv");

    let selectedFileDecrypt = null;

    function resetDecrypt(full = false) {
      if (full) {
        selectedFileDecrypt = null;
        fileInputDecrypt.value = "";
        fileInfoDecrypt.style.display = "none";
        fileNameDecrypt.textContent = "";
        fileSizeDecrypt.textContent = "";
        passwordDecrypt.value = "";
        metaDecryptName.textContent = "‚Äî";
        metaDecryptSize.textContent = "‚Äî";
        metaDecryptSaltIv.textContent = "‚Äî";
      }
      setStatus(statusDecrypt, "");
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "En attente‚Ä¶");
    }

    function handleDecryptFile(file) {
      if (!file) return;
      selectedFileDecrypt = file;
      fileInfoDecrypt.style.display = "flex";
      fileNameDecrypt.textContent = file.name;
      fileSizeDecrypt.textContent = formatBytes(file.size);
      setStatus(statusDecrypt, "");
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "Fichier pr√™t √† √™tre d√©chiffr√©");
    }

    dropzoneDecrypt.addEventListener("click", () => fileInputDecrypt.click());
    fileInputDecrypt.addEventListener("change", (e) => {
      const file = e.target.files[0];
      handleDecryptFile(file);
    });

    ["dragenter", "dragover"].forEach((eventName) => {
      dropzoneDecrypt.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneDecrypt.classList.add("dragover");
      });
    });

    ["dragleave", "drop"].forEach((eventName) => {
      dropzoneDecrypt.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneDecrypt.classList.remove("dragover");
      });
    });

    dropzoneDecrypt.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      const file = dt.files && dt.files[0];
      handleDecryptFile(file);
    });

    decryptBtn.addEventListener("click", async () => {
      if (!selectedFileDecrypt) {
        setStatus(statusDecrypt, "Choisis d‚Äôabord un fichier .encrypted √† d√©chiffrer.", "error");
        return;
      }
      const password = passwordDecrypt.value.trim();
      if (!password) {
        setStatus(statusDecrypt, "Entre le mot de passe utilis√© lors du chiffrement.", "error");
        return;
      }

      decryptBtn.disabled = true;
      clearDecrypt.disabled = true;
      setStatus(statusDecrypt, "");
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 5, "Initialisation‚Ä¶");

      try {
        setStatus(statusDecrypt, "Lecture du fichier chiffr√©‚Ä¶");
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 20, "Lecture du fichier‚Ä¶");
        const arrayBuffer = await selectedFileDecrypt.arrayBuffer();

        setStatus(statusDecrypt, "D√©rivation de la cl√©‚Ä¶");
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 40, "Pr√©paration de la cl√©‚Ä¶");

        const { dataBuffer, header, salt, iv } = await decryptWithPassword(password, arrayBuffer);

        const meta = header.meta || {};
        const originalName = meta.originalName || selectedFileDecrypt.name.replace(/\.encrypted$/i, "");
        const mimeType = meta.mimeType || "application/octet-stream";

        setStatus(statusDecrypt, "Reconstruction du fichier‚Ä¶");
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 80, "Finalisation‚Ä¶");

        const blob = new Blob([dataBuffer], { type: mimeType });

        metaDecryptName.textContent = originalName;
        metaDecryptSize.textContent = formatBytes(blob.size);
        metaDecryptSaltIv.textContent = "salt=" + toHex(salt) + " ‚Ä¢ iv=" + toHex(iv);

        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 100, "Termin√©");
        setStatus(statusDecrypt, "D√©chiffrement termin√©. T√©l√©chargement du fichier restaur√©.", "success");

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = originalName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        setStatus(statusDecrypt, "Erreur pendant le d√©chiffrement (mot de passe incorrect ? fichier corrompu ?).", "error");
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "En attente‚Ä¶");
      } finally {
        decryptBtn.disabled = false;
        clearDecrypt.disabled = false;
      }
    });

    clearDecrypt.addEventListener("click", () => {
      resetDecrypt(true);
    });

    resetDecrypt(true);

    // =========================
    // Coffre-fort (IndexedDB)
    // =========================
    const vaultIntro = document.getElementById("vaultIntro");
    const vaultMasterSetup = document.getElementById("vaultMasterSetup");
    const vaultMasterPassword = document.getElementById("vaultMasterPassword");
    const vaultMasterPasswordConfirm = document.getElementById("vaultMasterPasswordConfirm");
    const vaultMasterSetBtn = document.getElementById("vaultMasterSetBtn");
    const vaultUnlockedSection = document.getElementById("vaultUnlockedSection");
    const dropzoneVault = document.getElementById("dropzoneVault");
    const fileInputVault = document.getElementById("fileInputVault");
    const vaultList = document.getElementById("vaultList");
    const vaultEmpty = document.getElementById("vaultEmpty");
    const statusVault = document.getElementById("statusVault");
    const progressVault = document.getElementById("progressVault");
    const progressLabelVault = document.getElementById("progressLabelVault");
    const progressPercentVault = document.getElementById("progressPercentVault");
    const metaVaultName = document.getElementById("metaVaultName");
    const metaVaultSize = document.getElementById("metaVaultSize");
    const metaVaultDate = document.getElementById("metaVaultDate");
    const vaultPreview = document.getElementById("vaultPreview");
    const vaultUsage = document.getElementById("vaultUsage");

    let vaultDb = null;
    let vaultMasterKeyPassword = null; // non stock√©, juste en m√©moire
    const VAULT_DB_NAME = "secureVaultDB_v1";
    const VAULT_STORE_NAME = "files";
    const VAULT_META_KEY = "vault_meta_v1"; // stock√© dans localStorage (sel du master)

    function openVaultDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(VAULT_DB_NAME, 1);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(VAULT_STORE_NAME)) {
            const store = db.createObjectStore(VAULT_STORE_NAME, { keyPath: "id", autoIncrement: true });
            store.createIndex("by_date", "date", { unique: false });
          }
        };
        request.onsuccess = (event) => {
          resolve(event.target.result);
        };
        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    }

    async function getVaultDB() {
      if (vaultDb) return vaultDb;
      vaultDb = await openVaultDB();
      return vaultDb;
    }

    function getVaultMeta() {
      const raw = localStorage.getItem(VAULT_META_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function setVaultMeta(meta) {
      localStorage.setItem(VAULT_META_KEY, JSON.stringify(meta));
    }

    function hasVaultMaster() {
      const meta = getVaultMeta();
      return !!(meta && meta.salt);
    }

    function resetVaultUI() {
      setStatus(statusVault, "");
      setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      metaVaultName.textContent = "‚Äî";
      metaVaultSize.textContent = "‚Äî";
      metaVaultDate.textContent = "‚Äî";
      vaultPreview.innerHTML = '<div class="preview-placeholder">S√©lectionne un fichier dans le coffre pour tenter un aper√ßu (images, texte, PDF, vid√©o selon le navigateur).</div>';
    }

    async function initVaultFlow() {
      resetVaultUI();
      if (!hasVaultMaster()) {
        vaultIntro.classList.remove("hidden");
        vaultMasterSetup.classList.remove("hidden");
        vaultUnlockedSection.classList.add("hidden");
        setStatus(statusVault, "Aucun mot de passe ma√Ætre d√©fini. Commence par initialiser le coffre‚Äëfort.");
      } else if (!vaultMasterKeyPassword) {
        vaultIntro.textContent = "Mot de passe ma√Ætre requis pour d√©verrouiller le coffre‚Äëfort.";
        vaultIntro.classList.remove("hidden");
        vaultMasterSetup.classList.remove("hidden");
        vaultUnlockedSection.classList.add("hidden");
        vaultMasterPassword.placeholder = "Entre ton mot de passe ma√Ætre";
        vaultMasterPasswordConfirm.classList.add("hidden");
        vaultMasterSetBtn.textContent = "D√©verrouiller le coffre‚Äëfort";
        setStatus(statusVault, "Entre ton mot de passe ma√Ætre pour acc√©der au coffre.", "error");
      } else {
        vaultIntro.classList.add("hidden");
        vaultMasterSetup.classList.add("hidden");
        vaultUnlockedSection.classList.remove("hidden");
        await refreshVaultList();
        await updateVaultUsage();
      }
    }

    async function verifyOrCreateVaultMaster() {
      if (!hasVaultMaster()) {
        const pass1 = vaultMasterPassword.value.trim();
        const pass2 = vaultMasterPasswordConfirm.value.trim();
        if (!pass1 || !pass2) {
          setStatus(statusVault, "Entre et confirme un mot de passe ma√Ætre.", "error");
          return;
        }
        if (pass1 !== pass2) {
          setStatus(statusVault, "Les deux mots de passe ma√Ætre ne correspondent pas.", "error");
          return;
        }
        const salt = crypto.getRandomValues(new Uint8Array(16));
        setVaultMeta({ salt: Array.from(salt) });
        vaultMasterKeyPassword = pass1;
        vaultMasterPassword.value = "";
        vaultMasterPasswordConfirm.value = "";
        setStatus(statusVault, "Coffre‚Äëfort initialis√©. Mot de passe ma√Ætre d√©fini.", "success");
        vaultIntro.classList.add("hidden");
        vaultMasterSetup.classList.add("hidden");
        vaultUnlockedSection.classList.remove("hidden");
        await refreshVaultList();
        await updateVaultUsage();
      } else {
        const pass = vaultMasterPassword.value.trim();
        if (!pass) {
          setStatus(statusVault, "Entre ton mot de passe ma√Ætre.", "error");
          return;
        }
        // On ne peut pas v√©rifier sans tenter un d√©chiffrement r√©el, mais on l‚Äôaccepte ici.
        vaultMasterKeyPassword = pass;
        vaultMasterPassword.value = "";
        setStatus(statusVault, "Coffre‚Äëfort d√©verrouill√©.", "success");
        vaultIntro.classList.add("hidden");
        vaultMasterSetup.classList.add("hidden");
        vaultUnlockedSection.classList.remove("hidden");
        await refreshVaultList();
        await updateVaultUsage();
      }
    }

    vaultMasterSetBtn.addEventListener("click", () => {
      verifyOrCreateVaultMaster();
    });

    dropzoneVault.addEventListener("click", () => fileInputVault.click());
    fileInputVault.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      await addFilesToVault(files);
      fileInputVault.value = "";
    });

    ["dragenter", "dragover"].forEach((eventName) => {
      dropzoneVault.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneVault.classList.add("dragover");
      });
    });

    ["dragleave", "drop"].forEach((eventName) => {
      dropzoneVault.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropzoneVault.classList.remove("dragover");
      });
    });

    dropzoneVault.addEventListener("drop", async (e) => {
      const dt = e.dataTransfer;
      const files = Array.from(dt.files || []);
      if (!files.length) return;
      await addFilesToVault(files);
    });

    async function getVaultMasterSalt() {
      const meta = getVaultMeta();
      if (!meta || !meta.salt) throw new Error("Pas de sel de coffre‚Äëfort.");
      return new Uint8Array(meta.salt);
    }

    async function getVaultMasterKey() {
      if (!vaultMasterKeyPassword) throw new Error("Mot de passe ma√Ætre non d√©fini.");
      const salt = await getVaultMasterSalt();
      return deriveKeyFromPassword(vaultMasterKeyPassword, salt, 200000);
    }

    async function addFilesToVault(files) {
      if (!vaultMasterKeyPassword) {
        setStatus(statusVault, "D√©verrouille d‚Äôabord le coffre‚Äëfort avec ton mot de passe ma√Ætre.", "error");
        return;
      }
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE_NAME, "readwrite");
      const store = tx.objectStore(VAULT_STORE_NAME);

      let processed = 0;
      for (const file of files) {
        setStatus(statusVault, `Chiffrement de "${file.name}"‚Ä¶`);
        setProgress(progressVault, progressLabelVault, progressPercentVault, 10 + (processed / files.length) * 80, "Chiffrement‚Ä¶");
        const arrayBuffer = await file.arrayBuffer();

        const masterKey = await getVaultMasterKey();
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));

        const headerObj = {
          version: 1,
          meta: {
            originalName: file.name,
            originalSize: file.size,
            mimeType: file.type || "application/octet-stream",
            timestamp: Date.now(),
            vault: true,
          },
        };
        const headerJson = JSON.stringify(headerObj);
        const headerBuf = stringToArrayBuffer(headerJson);
        const headerLen = new Uint32Array([headerBuf.byteLength]);
        const payload = concatBuffers([headerLen.buffer, headerBuf, arrayBuffer]);

        const encrypted = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          masterKey,
          payload
        );

        const finalBuffer = concatBuffers([salt.buffer, iv.buffer, encrypted]);

        const record = {
          name: file.name,
          size: file.size,
          mimeType: file.type || "application/octet-stream",
          date: Date.now(),
          salt: Array.from(salt),
          iv: Array.from(iv),
          data: finalBuffer,
        };

        await new Promise((resolve, reject) => {
          const req = store.add(record);
          req.onsuccess = () => resolve();
          req.onerror = (e) => reject(e.target.error);
        });

        processed++;
      }

      await tx.complete;
      setStatus(statusVault, "Fichiers ajout√©s au coffre‚Äëfort.", "success");
      setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      await refreshVaultList();
      await updateVaultUsage();
    }

    async function refreshVaultList() {
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE_NAME, "readonly");
      const store = tx.objectStore(VAULT_STORE_NAME);
      const index = store.index("by_date");

      vaultList.innerHTML = "";
      let hasAny = false;

      await new Promise((resolve, reject) => {
        const req = index.openCursor(null, "prev");
        req.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            hasAny = true;
            const item = cursor.value;
            const el = document.createElement("div");
            el.className = "vault-item";
            el.dataset.id = item.id;

            const header = document.createElement("div");
            header.className = "vault-item-header";

            const nameEl = document.createElement("div");
            nameEl.className = "vault-item-name";
            nameEl.textContent = item.name;

            const badge = document.createElement("div");
            badge.className = "vault-badge";
            badge.textContent = formatBytes(item.size);

            header.appendChild(nameEl);
            header.appendChild(badge);

            const metaRow = document.createElement("div");
            metaRow.className = "vault-item-meta";
            const dateStr = new Date(item.date).toLocaleString();
            metaRow.textContent = dateStr + " ‚Ä¢ " + (item.mimeType || "application/octet-stream");

            const actions = document.createElement("div");
            actions.className = "vault-item-actions";

            const btnPreview = document.createElement("button");
            btnPreview.className = "btn btn-ghost";
            btnPreview.textContent = "Aper√ßu";
            btnPreview.addEventListener("click", () => {
              selectVaultItem(item);
              previewVaultItem(item);
            });

            const btnDownload = document.createElement("button");
            btnDownload.className = "btn btn-primary";
            btnDownload.textContent = "Restaurer";
            btnDownload.addEventListener("click", () => {
              selectVaultItem(item);
              restoreVaultItem(item);
            });

            const btnDelete = document.createElement("button");
            btnDelete.className = "btn btn-danger";
            btnDelete.textContent = "Supprimer";
            btnDelete.addEventListener("click", async () => {
              await deleteVaultItem(item.id);
              await refreshVaultList();
              await updateVaultUsage();
            });

            actions.appendChild(btnPreview);
            actions.appendChild(btnDownload);
            actions.appendChild(btnDelete);

            el.appendChild(header);
            el.appendChild(metaRow);
            el.appendChild(actions);

            vaultList.appendChild(el);

            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = (e) => reject(e.target.error);
      });

      if (!hasAny) {
        vaultList.appendChild(vaultEmpty);
        vaultEmpty.classList.remove("hidden");
      } else {
        vaultEmpty.classList.add("hidden");
      }
    }

    function selectVaultItem(item) {
      metaVaultName.textContent = item.name;
      metaVaultSize.textContent = formatBytes(item.size);
      metaVaultDate.textContent = new Date(item.date).toLocaleString();
    }

    async function decryptVaultRecord(record) {
      if (!vaultMasterKeyPassword) throw new Error("Mot de passe ma√Ætre non d√©fini.");
      const masterKey = await getVaultMasterKey();

      const salt = new Uint8Array(record.salt);
      const iv = new Uint8Array(record.iv);
      const encryptedBuffer = record.data;

      const cipherData = encryptedBuffer.slice(28); // 16 sel + 12 iv
      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        masterKey,
        cipherData
      );

      const view = new DataView(decrypted);
      const headerLen = view.getUint32(0, true);
      const headerBuf = decrypted.slice(4, 4 + headerLen);
      const dataBuf = decrypted.slice(4 + headerLen);

      const headerJson = arrayBufferToString(headerBuf);
      const headerObj = JSON.parse(headerJson);

      return {
        dataBuffer: dataBuf,
        header: headerObj,
        salt,
        iv,
      };
    }

    async function previewVaultItem(record) {
      try {
        setStatus(statusVault, "D√©chiffrement pour aper√ßu‚Ä¶");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 40, "D√©chiffrement‚Ä¶");
        const { dataBuffer, header } = await decryptVaultRecord(record);
        const meta = header.meta || {};
        const mimeType = meta.mimeType || record.mimeType || "application/octet-stream";
        const blob = new Blob([dataBuffer], { type: mimeType });
        const url = URL.createObjectURL(blob);

        vaultPreview.innerHTML = "";
        let content;

        if (mimeType.startsWith("image/")) {
          content = document.createElement("img");
          content.src = url;
        } else if (mimeType.startsWith("video/")) {
          content = document.createElement("video");
          content.src = url;
          content.controls = true;
        } else if (mimeType === "application/pdf") {
          content = document.createElement("iframe");
          content.src = url;
          content.style.width = "100%";
          content.style.height = "200px";
        } else if (mimeType.startsWith("text/") || mimeType === "application/json") {
          const text = await blob.text();
          content = document.createElement("pre");
          content.textContent = text.slice(0, 5000);
        } else {
          content = document.createElement("div");
          content.className = "preview-placeholder";
          content.textContent = "Ce type de fichier ne peut pas √™tre pr√©visualis√© ici. Utilise ‚ÄúRestaurer‚Äù pour le t√©l√©charger.";
        }

        vaultPreview.appendChild(content);
        setStatus(statusVault, "Aper√ßu g√©n√©r√© (dans la limite des capacit√©s du navigateur).", "success");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      } catch (err) {
        console.error(err);
        setStatus(statusVault, "Impossible de d√©chiffrer pour aper√ßu (mot de passe ma√Ætre incorrect ?).", "error");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      }
    }

    async function restoreVaultItem(record) {
      try {
        setStatus(statusVault, "D√©chiffrement pour restauration‚Ä¶");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 40, "D√©chiffrement‚Ä¶");
        const { dataBuffer, header } = await decryptVaultRecord(record);
        const meta = header.meta || {};
        const originalName = meta.originalName || record.name;
        const mimeType = meta.mimeType || record.mimeType || "application/octet-stream";
        const blob = new Blob([dataBuffer], { type: mimeType });

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = originalName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        setStatus(statusVault, "Fichier restaur√© et t√©l√©charg√©.", "success");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      } catch (err) {
        console.error(err);
        setStatus(statusVault, "Impossible de d√©chiffrer pour restauration (mot de passe ma√Ætre incorrect ?).", "error");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      }
    }

    async function deleteVaultItem(id) {
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE_NAME, "readwrite");
      const store = tx.objectStore(VAULT_STORE_NAME);
      await new Promise((resolve, reject) => {
        const req = store.delete(id);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e.target.error);
      });
      await tx.complete;
      setStatus(statusVault, "Fichier supprim√© du coffre‚Äëfort.", "success");
    }

    async function updateVaultUsage() {
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE_NAME, "readonly");
      const store = tx.objectStore(VAULT_STORE_NAME);

      let total = 0;
      await new Promise((resolve, reject) => {
        const req = store.openCursor();
        req.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            const item = cursor.value;
            total += item.data.byteLength || 0;
            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = (e) => reject(e.target.error);
      });

      vaultUsage.textContent = formatBytes(total);
    }

    // =========================
    // Param√®tres (modale)
    // =========================
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsModalBackdrop = document.getElementById("settingsModalBackdrop");
    const settingsCloseBtn = document.getElementById("settingsCloseBtn");
    const changeMasterBtn = document.getElementById("changeMasterBtn");
    const wipeVaultBtn = document.getElementById("wipeVaultBtn");
    const toggleAnimations = document.getElementById("toggleAnimations");

    settingsBtn.addEventListener("click", async () => {
      settingsModalBackdrop.classList.remove("hidden");
      await updateVaultUsage();
    });

    settingsCloseBtn.addEventListener("click", () => {
      settingsModalBackdrop.classList.add("hidden");
    });

    settingsModalBackdrop.addEventListener("click", (e) => {
      if (e.target === settingsModalBackdrop) {
        settingsModalBackdrop.classList.add("hidden");
      }
    });

    toggleAnimations.addEventListener("click", () => {
      toggleAnimations.classList.toggle("on");
      // Ici on pourrait activer/d√©sactiver des classes CSS d‚Äôanimations si besoin.
    });

    changeMasterBtn.addEventListener("click", async () => {
      if (!hasVaultMaster()) {
        alert("Aucun mot de passe ma√Ætre n‚Äôest encore d√©fini. Va dans l‚Äôonglet Coffre‚Äëfort pour l‚Äôinitialiser.");
        return;
      }
      const oldPass = prompt("Ancien mot de passe ma√Ætre :");
      if (!oldPass) return;
      const newPass = prompt("Nouveau mot de passe ma√Ætre :");
      if (!newPass) return;
      const confirmPass = prompt("Confirme le nouveau mot de passe ma√Ætre :");
      if (newPass !== confirmPass) {
        alert("Les deux nouveaux mots de passe ne correspondent pas.");
        return;
      }
      // On ne peut pas re-chiffrer tout le coffre facilement sans tout relire.
      // Ici, on change simplement le sel et le mot de passe en m√©moire.
      const salt = crypto.getRandomValues(new Uint8Array(16));
      setVaultMeta({ salt: Array.from(salt) });
      vaultMasterKeyPassword = newPass;
      alert("Mot de passe ma√Ætre mis √† jour. Les fichiers existants restent accessibles avec ce nouveau mot de passe.");
    });

    wipeVaultBtn.addEventListener("click", async () => {
      if (!confirm("Tu es s√ªr ? Cela effacera d√©finitivement tous les fichiers du coffre‚Äëfort sur ce navigateur.")) {
        return;
      }
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE_NAME, "readwrite");
      const store = tx.objectStore(VAULT_STORE_NAME);
      await new Promise((resolve, reject) => {
        const req = store.clear();
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e.target.error);
      });
      await tx.complete;
      localStorage.removeItem(VAULT_META_KEY);
      vaultMasterKeyPassword = null;
      await refreshVaultList();
      await updateVaultUsage();
      await initVaultFlow();
      alert("Coffre‚Äëfort vid√© et r√©initialis√©.");
    });

    // =========================
    // Init
    // =========================
    (async () => {
      showTab("encrypt");
      resetVaultUI();
      // On n‚Äôouvre le coffre qu‚Äô√† la demande (onglet).
    })();
  </script>
</body>
</html>
