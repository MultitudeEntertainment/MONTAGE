<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Coffre & chiffreur de fichiers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #0b1220;
      --accent: #38bdf8;
      --accent2: #6366f1;
      --text: #e5e7eb;
      --soft: #9ca3af;
      --danger: #f97373;
      --radius: 14px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
    body {
      min-height: 100vh;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .app {
      width: 100%;
      max-width: 1000px;
      background: linear-gradient(145deg, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
      border-radius: 22px;
      box-shadow: 0 24px 80px rgba(15,23,42,0.9), 0 0 0 1px rgba(148,163,184,0.15);
      padding: 18px 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    @media (min-width: 900px) {
      .app { padding: 22px 22px 22px; gap: 16px; }
    }
    .header { display: flex; flex-direction: column; gap: 6px; }
    .title-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
    h1 { font-size: 1.35rem; display: flex; align-items: center; gap: 8px; letter-spacing: 0.03em; }
    .badge {
      font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.12em;
      padding: 3px 8px; border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5); color: var(--soft);
    }
    .subtitle { font-size: 0.85rem; color: var(--soft); max-width: 620px; }
    .tabs {
      display: flex; flex-wrap: wrap; gap: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      padding: 4px;
      border: 1px solid rgba(30,64,175,0.7);
    }
    .tab-btn {
      border-radius: 999px; border: none;
      padding: 6px 14px; font-size: 0.82rem;
      cursor: pointer; background: transparent; color: var(--soft);
      display: inline-flex; align-items: center; gap: 6px;
      transition: background 0.15s, color 0.15s, transform 0.1s;
    }
    .tab-btn.active {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #0b1120; transform: translateY(-1px);
    }
    .tab-btn:not(.active):hover { color: var(--text); transform: translateY(-1px); }
    .main { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 900px) {
      .main { grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr); gap: 16px; }
    }
    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid rgba(148,163,184,0.25);
      padding: 14px 14px 16px;
      display: flex; flex-direction: column; gap: 10px;
    }
    @media (min-width: 900px) { .panel { padding: 16px 16px 18px; } }
    .panel-title { font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--soft); }
    .panel-sub { font-size: 0.8rem; color: var(--soft); margin-top: 2px; }
    .dropzone {
      border-radius: 14px;
      border: 1px dashed rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      padding: 16px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 8px; text-align: center; cursor: pointer;
      transition: border-color 0.18s, background 0.18s, transform 0.12s;
    }
    .dropzone:hover { border-color: var(--accent); background: rgba(15,23,42,1); transform: translateY(-1px); }
    .dropzone.dragover {
      border-color: var(--accent);
      background: rgba(15,23,42,1);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.4);
    }
    .file-input { display: none; }
    .drop-main { font-size: 0.9rem; }
    .drop-main span { color: var(--accent); font-weight: 500; }
    .drop-sub { font-size: 0.78rem; color: var(--soft); }
    .file-info {
      font-size: 0.8rem; color: var(--soft);
      display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap;
    }
    .file-name { max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-size { opacity: 0.8; }
    .field { display: flex; flex-direction: column; gap: 4px; }
    .field-label { font-size: 0.8rem; color: var(--soft); display: flex; justify-content: space-between; gap: 8px; }
    .field-label span { font-size: 0.7rem; opacity: 0.8; }
    .input {
      width: 100%; border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.9);
      color: var(--text);
      padding: 8px 12px; font-size: 0.85rem;
      outline: none;
      transition: border-color 0.18s, box-shadow 0.18s, background 0.18s;
    }
    .input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.4);
      background: rgba(15,23,42,1);
    }
    .input::placeholder { color: rgba(148,163,184,0.8); }
    .actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .btn {
      border-radius: 999px; border: none;
      padding: 7px 14px; font-size: 0.82rem; font-weight: 500;
      cursor: pointer; display: inline-flex; align-items: center; gap: 6px;
      transition: transform 0.12s, box-shadow 0.12s, background 0.18s, opacity 0.12s;
      white-space: nowrap;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #0b1120;
      box-shadow: 0 10px 30px rgba(56,189,248,0.45);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 14px 40px rgba(56,189,248,0.55); }
    .btn-ghost {
      background: rgba(15,23,42,0.9);
      color: var(--soft);
      border: 1px solid rgba(148,163,184,0.5);
    }
    .btn-ghost:hover { background: rgba(15,23,42,1); color: var(--text); }
    .btn-danger {
      background: rgba(127,29,29,0.9);
      color: #fee2e2;
      border: 1px solid rgba(248,113,113,0.7);
    }
    .btn-danger:hover { background: rgba(153,27,27,1); }
    .btn:disabled { opacity: 0.6; cursor: default; transform: none; box-shadow: none; }
    .status { font-size: 0.78rem; color: var(--soft); min-height: 1.1em; }
    .status.error { color: var(--danger); }
    .status.success { color: #4ade80; }
    .progress-bar {
      width: 100%; height: 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(30,64,175,0.8);
      overflow: hidden;
    }
    .progress-inner {
      height: 100%; width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      transition: width 0.15s ease;
    }
    .progress-label {
      font-size: 0.75rem; color: var(--soft);
      display: flex; justify-content: space-between; gap: 8px;
    }
    .meta { font-size: 0.78rem; color: var(--soft); display: flex; flex-direction: column; gap: 4px; }
    .meta-row { display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .meta-key { opacity: 0.8; }
    .meta-value {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem; color: #e0f2fe;
    }
    .hidden { display: none !important; }

    /* Coffre */
    .vault-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; font-size: 0.8rem; }
    .vault-search { flex: 1; min-width: 140px; }
    .vault-list {
      margin-top: 6px;
      max-height: 240px;
      overflow: auto;
      display: flex; flex-direction: column; gap: 6px;
    }
    .vault-empty { font-size: 0.8rem; color: var(--soft); }
    .vault-item {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
      padding: 6px 8px;
      display: flex; flex-direction: column; gap: 4px;
      font-size: 0.78rem;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }
    .vault-item:hover { border-color: var(--accent); background: rgba(15,23,42,1); }
    .vault-item.selected { border-color: var(--accent2); box-shadow: 0 0 0 1px rgba(99,102,241,0.7); }
    .vault-item-header { display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .vault-item-name { font-weight: 500; max-width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .vault-item-meta { font-size: 0.72rem; color: var(--soft); }
    .vault-item-actions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; }
    .preview-frame {
      border-radius: 10px;
      border: 1px solid rgba(30,64,175,0.7);
      background: rgba(15,23,42,0.9);
      padding: 6px;
      max-height: 220px;
      overflow: auto;
      font-size: 0.8rem;
    }
    .preview-frame img,
    .preview-frame video { max-width: 100%; border-radius: 8px; }
    .preview-placeholder { font-size: 0.78rem; color: var(--soft); }

    .footer {
      font-size: 0.72rem; color: var(--soft);
      display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap;
      border-top: 1px solid rgba(30,64,175,0.6);
      padding-top: 6px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div class="title-row">
        <div>
          <h1>üîê Coffre & chiffreur</h1>
          <div class="badge">Client‚Äëside ‚Ä¢ Aucune donn√©e envoy√©e</div>
          <p class="subtitle">
            Chiffre, d√©chiffre et stocke des fichiers sensibles dans un coffre local prot√©g√© par mot de passe.
          </p>
        </div>
      </div>
      <div class="tabs">
        <button class="tab-btn active" data-tab="encrypt">üß© Chiffrer</button>
        <button class="tab-btn" data-tab="decrypt">üîì D√©chiffrer</button>
        <button class="tab-btn" data-tab="vault">üóÑÔ∏è Coffre‚Äëfort</button>
      </div>
    </header>

    <main class="main">
      <!-- Colonne gauche -->
      <section class="panel">
        <!-- Chiffrer -->
        <div id="panelEncrypt">
          <div class="panel-title">Chiffrer un fichier</div>
          <div class="panel-sub">Cr√©e une copie chiffr√©e (.encrypted) sans toucher √† l‚Äôoriginal.</div>

          <label class="dropzone" id="dropzoneEncrypt">
            <input type="file" id="fileInputEncrypt" class="file-input" />
            <div class="drop-main"><span>Cliquer pour choisir</span> ou d√©poser un fichier</div>
            <div class="drop-sub">Tous types accept√©s (mp4, jpg, pdf, docx, zip, etc.)</div>
          </label>

          <div class="file-info" id="fileInfoEncrypt" style="display:none;">
            <div class="file-name" id="fileNameEncrypt"></div>
            <div class="file-size" id="fileSizeEncrypt"></div>
          </div>

          <div class="field">
            <div class="field-label">
              Mot de passe
              <span>Servira √† d√©chiffrer plus tard</span>
            </div>
            <input type="password" id="passwordEncrypt" class="input" placeholder="Choisis un mot de passe solide" />
          </div>

          <div class="actions">
            <button type="button" class="btn btn-ghost" id="clearEncrypt">R√©initialiser</button>
            <button type="button" class="btn btn-primary" id="encryptBtn">Chiffrer &amp; t√©l√©charger</button>
          </div>

          <div class="status" id="statusEncrypt"></div>
        </div>

        <!-- D√©chiffrer -->
        <div id="panelDecrypt" class="hidden">
          <div class="panel-title">D√©chiffrer un fichier</div>
          <div class="panel-sub">Restaure un fichier original √† partir d‚Äôun .encrypted.</div>

          <label class="dropzone" id="dropzoneDecrypt">
            <input type="file" id="fileInputDecrypt" class="file-input" />
            <div class="drop-main"><span>Cliquer pour choisir</span> ou d√©poser un fichier .encrypted</div>
            <div class="drop-sub">Utilise le m√™me mot de passe que lors du chiffrement.</div>
          </label>

          <div class="file-info" id="fileInfoDecrypt" style="display:none;">
            <div class="file-name" id="fileNameDecrypt"></div>
            <div class="file-size" id="fileSizeDecrypt"></div>
          </div>

          <div class="field">
            <div class="field-label">
              Mot de passe
              <span>Doit √™tre identique √† celui du chiffrement</span>
            </div>
            <input type="password" id="passwordDecrypt" class="input" placeholder="Entre le mot de passe utilis√©" />
          </div>

          <div class="actions">
            <button type="button" class="btn btn-ghost" id="clearDecrypt">R√©initialiser</button>
            <button type="button" class="btn btn-primary" id="decryptBtn">D√©chiffrer &amp; t√©l√©charger</button>
          </div>

          <div class="status" id="statusDecrypt"></div>
        </div>

        <!-- Coffre -->
        <div id="panelVault" class="hidden">
          <div class="panel-title">Coffre‚Äëfort</div>
          <div class="panel-sub">
            Stocke des fichiers chiffr√©s localement (IndexedDB). Accessible 24h/24 sur ce navigateur, avec mot de passe ma√Ætre.
          </div>

          <div class="status" id="vaultIntro">
            Premi√®re utilisation : choisis un <strong>mot de passe ma√Ætre</strong>. Si tu le perds, les fichiers sont perdus.
          </div>

          <div class="field" id="vaultMasterSetup">
            <div class="field-label">
              Mot de passe ma√Ætre
              <span>√Ä retenir absolument</span>
            </div>
            <input type="password" id="vaultMasterPassword" class="input" placeholder="Cr√©e ou entre ton mot de passe ma√Ætre" />
            <div class="actions">
              <button type="button" class="btn btn-primary" id="vaultMasterBtn">Valider</button>
            </div>
          </div>

          <div id="vaultUnlocked" class="hidden">
            <div class="vault-toolbar">
              <div class="vault-search">
                <input type="text" id="vaultSearch" class="input" placeholder="Rechercher dans le coffre‚Ä¶" />
              </div>
              <div>
                <select id="vaultSort" class="input">
                  <option value="date_desc">Plus r√©cents</option>
                  <option value="date_asc">Plus anciens</option>
                  <option value="name_asc">Nom A‚ÜíZ</option>
                  <option value="name_desc">Nom Z‚ÜíA</option>
                </select>
              </div>
            </div>

            <label class="dropzone" id="dropzoneVault">
              <input type="file" id="fileInputVault" class="file-input" multiple />
              <div class="drop-main"><span>Cliquer pour ajouter</span> ou d√©poser des fichiers</div>
              <div class="drop-sub">Ils seront chiffr√©s et stock√©s dans ce coffre.</div>
            </label>

            <div class="vault-list" id="vaultList">
              <div class="vault-empty" id="vaultEmpty">Aucun fichier dans le coffre pour l‚Äôinstant.</div>
            </div>
          </div>

          <div class="status" id="statusVault"></div>
        </div>
      </section>

      <!-- Colonne droite -->
      <section class="panel">
        <!-- Side encrypt -->
        <div id="sideEncrypt">
          <div class="panel-title">Progression &amp; d√©tails</div>
          <div class="progress-bar"><div class="progress-inner" id="progressEncrypt"></div></div>
          <div class="progress-label">
            <span id="progressLabelEncrypt">En attente‚Ä¶</span>
            <span id="progressPercentEncrypt">0%</span>
          </div>
          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Nom de sortie</span>
              <span class="meta-value" id="metaEncryptName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille chiffr√©e</span>
              <span class="meta-value" id="metaEncryptSize">‚Äî</span>
            </div>
          </div>
        </div>

        <!-- Side decrypt -->
        <div id="sideDecrypt" class="hidden">
          <div class="panel-title">Progression &amp; d√©tails</div>
          <div class="progress-bar"><div class="progress-inner" id="progressDecrypt"></div></div>
          <div class="progress-label">
            <span id="progressLabelDecrypt">En attente‚Ä¶</span>
            <span id="progressPercentDecrypt">0%</span>
          </div>
          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Nom restaur√©</span>
              <span class="meta-value" id="metaDecryptName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille d√©chiffr√©e</span>
              <span class="meta-value" id="metaDecryptSize">‚Äî</span>
            </div>
          </div>
        </div>

        <!-- Side vault -->
        <div id="sideVault" class="hidden">
          <div class="panel-title">Aper√ßu &amp; infos</div>
          <div class="progress-bar"><div class="progress-inner" id="progressVault"></div></div>
          <div class="progress-label">
            <span id="progressLabelVault">En attente‚Ä¶</span>
            <span id="progressPercentVault">0%</span>
          </div>
          <div class="meta">
            <div class="meta-row">
              <span class="meta-key">Fichier s√©lectionn√©</span>
              <span class="meta-value" id="metaVaultName">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Taille</span>
              <span class="meta-value" id="metaVaultSize">‚Äî</span>
            </div>
            <div class="meta-row">
              <span class="meta-key">Date</span>
              <span class="meta-value" id="metaVaultDate">‚Äî</span>
            </div>
          </div>
          <div class="preview-frame" id="vaultPreview">
            <div class="preview-placeholder">
              S√©lectionne un fichier dans le coffre pour tenter un aper√ßu (images, texte, PDF, vid√©o).
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <span>Les fichiers originaux ne sont jamais modifi√©s, seules des copies chiffr√©es sont cr√©√©es ou stock√©es.</span>
      <span><strong>Important :</strong> sans mot de passe (normal ou ma√Ætre), les fichiers sont irr√©cup√©rables.</span>
    </footer>
  </div>

  <script>
    // Helpers
    function formatBytes(bytes) {
      if (!bytes) return "0 o";
      const k = 1024, sizes = ["o", "Ko", "Mo", "Go", "To"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }
    function setStatus(el, msg, type = "") {
      el.textContent = msg || "";
      el.className = "status" + (type ? " " + type : "");
    }
    function setProgress(bar, labelEl, percentEl, p, label) {
      const v = Math.max(0, Math.min(100, p));
      bar.style.width = v + "%";
      if (percentEl) percentEl.textContent = v.toFixed(0) + "%";
      if (label && labelEl) labelEl.textContent = label;
    }
    function concatBuffers(buffers) {
      let total = 0;
      for (const b of buffers) total += b.byteLength;
      const tmp = new Uint8Array(total);
      let offset = 0;
      for (const b of buffers) {
        tmp.set(new Uint8Array(b), offset);
        offset += b.byteLength;
      }
      return tmp.buffer;
    }
    function strToBuf(str) { return new TextEncoder().encode(str).buffer; }
    function bufToStr(buf) { return new TextDecoder().decode(buf); }

    async function deriveKey(password, salt, iterations = 150000) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptWithPassword(password, dataBuffer, meta) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);

      const header = { v: 1, meta };
      const headerBuf = strToBuf(JSON.stringify(header));
      const headerLen = new Uint32Array([headerBuf.byteLength]);
      const payload = concatBuffers([headerLen.buffer, headerBuf, dataBuffer]);

      const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, payload);
      const finalBuffer = concatBuffers([salt.buffer, iv.buffer, encrypted]);
      return { finalBuffer, salt, iv };
    }

    async function decryptWithPassword(password, encryptedBuffer) {
      const salt = new Uint8Array(encryptedBuffer.slice(0, 16));
      const iv = new Uint8Array(encryptedBuffer.slice(16, 28));
      const cipherData = encryptedBuffer.slice(28);
      const key = await deriveKey(password, salt);

      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherData);
      const view = new DataView(decrypted);
      const headerLen = view.getUint32(0, true);
      const headerBuf = decrypted.slice(4, 4 + headerLen);
      const dataBuf = decrypted.slice(4 + headerLen);
      const header = JSON.parse(bufToStr(headerBuf));
      return { dataBuffer: dataBuf, header, salt, iv };
    }

    // Onglets
    const tabBtns = document.querySelectorAll(".tab-btn");
    const panelEncrypt = document.getElementById("panelEncrypt");
    const panelDecrypt = document.getElementById("panelDecrypt");
    const panelVault = document.getElementById("panelVault");
    const sideEncrypt = document.getElementById("sideEncrypt");
    const sideDecrypt = document.getElementById("sideDecrypt");
    const sideVault = document.getElementById("sideVault");

    function showTab(tab) {
      tabBtns.forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
      panelEncrypt.classList.toggle("hidden", tab !== "encrypt");
      panelDecrypt.classList.toggle("hidden", tab !== "decrypt");
      panelVault.classList.toggle("hidden", tab !== "vault");
      sideEncrypt.classList.toggle("hidden", tab !== "encrypt");
      sideDecrypt.classList.toggle("hidden", tab !== "decrypt");
      sideVault.classList.toggle("hidden", tab !== "vault");
      if (tab === "vault") initVault();
    }
    tabBtns.forEach(b => b.addEventListener("click", () => showTab(b.dataset.tab)));

    // Chiffrer
    const fileInputEncrypt = document.getElementById("fileInputEncrypt");
    const dropzoneEncrypt = document.getElementById("dropzoneEncrypt");
    const fileInfoEncrypt = document.getElementById("fileInfoEncrypt");
    const fileNameEncrypt = document.getElementById("fileNameEncrypt");
    const fileSizeEncrypt = document.getElementById("fileSizeEncrypt");
    const passwordEncrypt = document.getElementById("passwordEncrypt");
    const encryptBtn = document.getElementById("encryptBtn");
    const clearEncrypt = document.getElementById("clearEncrypt");
    const statusEncrypt = document.getElementById("statusEncrypt");
    const progressEncrypt = document.getElementById("progressEncrypt");
    const progressLabelEncrypt = document.getElementById("progressLabelEncrypt");
    const progressPercentEncrypt = document.getElementById("progressPercentEncrypt");
    const metaEncryptName = document.getElementById("metaEncryptName");
    const metaEncryptSize = document.getElementById("metaEncryptSize");
    let fileEncrypt = null;

    function resetEncrypt(full = false) {
      if (full) {
        fileEncrypt = null;
        fileInputEncrypt.value = "";
        fileInfoEncrypt.style.display = "none";
        fileNameEncrypt.textContent = "";
        fileSizeEncrypt.textContent = "";
        passwordEncrypt.value = "";
        metaEncryptName.textContent = "‚Äî";
        metaEncryptSize.textContent = "‚Äî";
      }
      setStatus(statusEncrypt, "");
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "En attente‚Ä¶");
    }

    function handleEncryptFile(file) {
      if (!file) return;
      fileEncrypt = file;
      fileInfoEncrypt.style.display = "flex";
      fileNameEncrypt.textContent = file.name;
      fileSizeEncrypt.textContent = formatBytes(file.size);
      setStatus(statusEncrypt, "");
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "Fichier pr√™t √† √™tre chiffr√©");
    }

    dropzoneEncrypt.addEventListener("click", () => fileInputEncrypt.click());
    fileInputEncrypt.addEventListener("change", e => handleEncryptFile(e.target.files[0]));
    ["dragenter","dragover"].forEach(ev => dropzoneEncrypt.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneEncrypt.classList.add("dragover");
    }));
    ["dragleave","drop"].forEach(ev => dropzoneEncrypt.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneEncrypt.classList.remove("dragover");
    }));
    dropzoneEncrypt.addEventListener("drop", e => handleEncryptFile(e.dataTransfer.files[0]));

    encryptBtn.addEventListener("click", async () => {
      if (!fileEncrypt) { setStatus(statusEncrypt, "Choisis un fichier √† chiffrer.", "error"); return; }
      const pwd = passwordEncrypt.value.trim();
      if (!pwd) { setStatus(statusEncrypt, "Entre un mot de passe.", "error"); return; }

      encryptBtn.disabled = true;
      clearEncrypt.disabled = true;
      setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 10, "Lecture du fichier‚Ä¶");
      try {
        const buf = await fileEncrypt.arrayBuffer();
        const meta = {
          name: fileEncrypt.name,
          size: fileEncrypt.size,
          type: fileEncrypt.type || "application/octet-stream",
          ts: Date.now()
        };
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 50, "Chiffrement‚Ä¶");
        const { finalBuffer } = await encryptWithPassword(pwd, buf, meta);
        const outName = fileEncrypt.name + ".encrypted";
        const blob = new Blob([finalBuffer], { type: "application/octet-stream" });

        metaEncryptName.textContent = outName;
        metaEncryptSize.textContent = formatBytes(blob.size);
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 100, "Termin√©");
        setStatus(statusEncrypt, "Chiffrement termin√©, t√©l√©chargement en cours.", "success");

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = outName;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      } catch (e) {
        console.error(e);
        setStatus(statusEncrypt, "Erreur pendant le chiffrement.", "error");
        setProgress(progressEncrypt, progressLabelEncrypt, progressPercentEncrypt, 0, "En attente‚Ä¶");
      } finally {
        encryptBtn.disabled = false;
        clearEncrypt.disabled = false;
      }
    });
    clearEncrypt.addEventListener("click", () => resetEncrypt(true));
    resetEncrypt(true);

    // D√©chiffrer
    const fileInputDecrypt = document.getElementById("fileInputDecrypt");
    const dropzoneDecrypt = document.getElementById("dropzoneDecrypt");
    const fileInfoDecrypt = document.getElementById("fileInfoDecrypt");
    const fileNameDecrypt = document.getElementById("fileNameDecrypt");
    const fileSizeDecrypt = document.getElementById("fileSizeDecrypt");
    const passwordDecrypt = document.getElementById("passwordDecrypt");
    const decryptBtn = document.getElementById("decryptBtn");
    const clearDecrypt = document.getElementById("clearDecrypt");
    const statusDecrypt = document.getElementById("statusDecrypt");
    const progressDecrypt = document.getElementById("progressDecrypt");
    const progressLabelDecrypt = document.getElementById("progressLabelDecrypt");
    const progressPercentDecrypt = document.getElementById("progressPercentDecrypt");
    const metaDecryptName = document.getElementById("metaDecryptName");
    const metaDecryptSize = document.getElementById("metaDecryptSize");
    let fileDecrypt = null;

    function resetDecrypt(full = false) {
      if (full) {
        fileDecrypt = null;
        fileInputDecrypt.value = "";
        fileInfoDecrypt.style.display = "none";
        fileNameDecrypt.textContent = "";
        fileSizeDecrypt.textContent = "";
        passwordDecrypt.value = "";
        metaDecryptName.textContent = "‚Äî";
        metaDecryptSize.textContent = "‚Äî";
      }
      setStatus(statusDecrypt, "");
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "En attente‚Ä¶");
    }

    function handleDecryptFile(file) {
      if (!file) return;
      fileDecrypt = file;
      fileInfoDecrypt.style.display = "flex";
      fileNameDecrypt.textContent = file.name;
      fileSizeDecrypt.textContent = formatBytes(file.size);
      setStatus(statusDecrypt, "");
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "Fichier pr√™t √† √™tre d√©chiffr√©");
    }

    dropzoneDecrypt.addEventListener("click", () => fileInputDecrypt.click());
    fileInputDecrypt.addEventListener("change", e => handleDecryptFile(e.target.files[0]));
    ["dragenter","dragover"].forEach(ev => dropzoneDecrypt.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneDecrypt.classList.add("dragover");
    }));
    ["dragleave","drop"].forEach(ev => dropzoneDecrypt.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneDecrypt.classList.remove("dragover");
    }));
    dropzoneDecrypt.addEventListener("drop", e => handleDecryptFile(e.dataTransfer.files[0]));

    decryptBtn.addEventListener("click", async () => {
      if (!fileDecrypt) { setStatus(statusDecrypt, "Choisis un fichier .encrypted.", "error"); return; }
      const pwd = passwordDecrypt.value.trim();
      if (!pwd) { setStatus(statusDecrypt, "Entre le mot de passe utilis√©.", "error"); return; }

      decryptBtn.disabled = true;
      clearDecrypt.disabled = true;
      setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 10, "Lecture du fichier‚Ä¶");
      try {
        const buf = await fileDecrypt.arrayBuffer();
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 40, "D√©chiffrement‚Ä¶");
        const { dataBuffer, header } = await decryptWithPassword(pwd, buf);
        const meta = header.meta || {};
        const name = meta.name || fileDecrypt.name.replace(/\.encrypted$/i, "");
        const type = meta.type || "application/octet-stream";
        const blob = new Blob([dataBuffer], { type });

        metaDecryptName.textContent = name;
        metaDecryptSize.textContent = formatBytes(blob.size);
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 100, "Termin√©");
        setStatus(statusDecrypt, "D√©chiffrement termin√©, t√©l√©chargement en cours.", "success");

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = name;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      } catch (e) {
        console.error(e);
        setStatus(statusDecrypt, "Erreur pendant le d√©chiffrement (mot de passe ou fichier).", "error");
        setProgress(progressDecrypt, progressLabelDecrypt, progressPercentDecrypt, 0, "En attente‚Ä¶");
      } finally {
        decryptBtn.disabled = false;
        clearDecrypt.disabled = false;
      }
    });
    clearDecrypt.addEventListener("click", () => resetDecrypt(true));
    resetDecrypt(true);

    // Coffre (IndexedDB)
    const VAULT_DB = "vault_db_v1";
    const VAULT_STORE = "files";
    const VAULT_META_KEY = "vault_meta_v1";
    const VAULT_SESSION_KEY = "vault_session_v1";

    const vaultIntro = document.getElementById("vaultIntro");
    const vaultMasterSetup = document.getElementById("vaultMasterSetup");
    const vaultMasterPassword = document.getElementById("vaultMasterPassword");
    const vaultMasterBtn = document.getElementById("vaultMasterBtn");
    const vaultUnlocked = document.getElementById("vaultUnlocked");
    const dropzoneVault = document.getElementById("dropzoneVault");
    const fileInputVault = document.getElementById("fileInputVault");
    const vaultList = document.getElementById("vaultList");
    const vaultEmpty = document.getElementById("vaultEmpty");
    const statusVault = document.getElementById("statusVault");
    const progressVault = document.getElementById("progressVault");
    const progressLabelVault = document.getElementById("progressLabelVault");
    const progressPercentVault = document.getElementById("progressPercentVault");
    const metaVaultName = document.getElementById("metaVaultName");
    const metaVaultSize = document.getElementById("metaVaultSize");
    const metaVaultDate = document.getElementById("metaVaultDate");
    const vaultPreview = document.getElementById("vaultPreview");
    const vaultSearch = document.getElementById("vaultSearch");
    const vaultSort = document.getElementById("vaultSort");

    let vaultDb = null;
    let vaultMasterPwdSession = null;
    let vaultItems = [];
    let vaultSelectedId = null;

    function getVaultMeta() {
      const raw = localStorage.getItem(VAULT_META_KEY);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }
    function setVaultMeta(meta) { localStorage.setItem(VAULT_META_KEY, JSON.stringify(meta)); }

    function openVaultDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(VAULT_DB, 1);
        req.onupgradeneeded = e => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(VAULT_STORE)) {
            const store = db.createObjectStore(VAULT_STORE, { keyPath: "id", autoIncrement: true });
            store.createIndex("by_date", "date", { unique: false });
          }
        };
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e.target.error);
      });
    }
    async function getVaultDB() {
      if (vaultDb) return vaultDb;
      vaultDb = await openVaultDB();
      return vaultDb;
    }

    function resetVaultUI() {
      setStatus(statusVault, "");
      setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      metaVaultName.textContent = "‚Äî";
      metaVaultSize.textContent = "‚Äî";
      metaVaultDate.textContent = "‚Äî";
      vaultPreview.innerHTML = '<div class="preview-placeholder">S√©lectionne un fichier dans le coffre pour tenter un aper√ßu.</div>';
      vaultSelectedId = null;
    }

    async function initVault() {
      resetVaultUI();
      const meta = getVaultMeta();
      const sessionFlag = sessionStorage.getItem(VAULT_SESSION_KEY);

      if (!meta) {
        vaultIntro.classList.remove("hidden");
        vaultMasterSetup.classList.remove("hidden");
        vaultUnlocked.classList.add("hidden");
        vaultIntro.innerHTML = 'Premi√®re utilisation : choisis un <strong>mot de passe ma√Ætre</strong>.';
      } else if (!sessionFlag || !vaultMasterPwdSession) {
        vaultIntro.classList.remove("hidden");
        vaultMasterSetup.classList.remove("hidden");
        vaultUnlocked.classList.add("hidden");
        vaultIntro.textContent = "Entre ton mot de passe ma√Ætre pour d√©verrouiller le coffre (une fois par session).";
      } else {
        vaultIntro.classList.add("hidden");
        vaultMasterSetup.classList.add("hidden");
        vaultUnlocked.classList.remove("hidden");
        await refreshVaultList();
      }
    }

    vaultMasterBtn.addEventListener("click", () => {
      const pwd = vaultMasterPassword.value.trim();
      if (!pwd) { setStatus(statusVault, "Entre un mot de passe ma√Ætre.", "error"); return; }

      const meta = getVaultMeta();
      if (!meta) {
        const salt = Array.from(crypto.getRandomValues(new Uint8Array(16)));
        setVaultMeta({ salt });
      }
      vaultMasterPwdSession = pwd;
      sessionStorage.setItem(VAULT_SESSION_KEY, "1");
      vaultMasterPassword.value = "";
      setStatus(statusVault, "Coffre d√©verrouill√© pour cette session.", "success");
      vaultIntro.classList.add("hidden");
      vaultMasterSetup.classList.add("hidden");
      vaultUnlocked.classList.remove("hidden");
      refreshVaultList();
    });

    async function getVaultMasterKey() {
      if (!vaultMasterPwdSession) throw new Error("Mot de passe ma√Ætre non d√©fini.");
      const meta = getVaultMeta();
      if (!meta || !meta.salt) throw new Error("Meta coffre manquante.");
      const salt = new Uint8Array(meta.salt);
      return deriveKey(vaultMasterPwdSession, salt, 200000);
    }

    dropzoneVault.addEventListener("click", () => fileInputVault.click());
    fileInputVault.addEventListener("change", async e => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      await addFilesToVault(files);
      fileInputVault.value = "";
    });
    ["dragenter","dragover"].forEach(ev => dropzoneVault.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneVault.classList.add("dragover");
    }));
    ["dragleave","drop"].forEach(ev => dropzoneVault.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropzoneVault.classList.remove("dragover");
    }));
    dropzoneVault.addEventListener("drop", async e => {
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      await addFilesToVault(files);
    });

    async function addFilesToVault(files) {
      if (!vaultMasterPwdSession) { setStatus(statusVault, "D√©verrouille d‚Äôabord le coffre.", "error"); return; }
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE, "readwrite");
      const store = tx.objectStore(VAULT_STORE);
      const key = await getVaultMasterKey();

      let done = 0;
      for (const file of files) {
        setProgress(progressVault, progressLabelVault, progressPercentVault, 10 + (done / files.length) * 70, "Chiffrement‚Ä¶");
        const buf = await file.arrayBuffer();

        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));

        const header = {
          v: 1,
          meta: {
            name: file.name,
            size: file.size,
            type: file.type || "application/octet-stream",
            ts: Date.now()
          }
        };
        const headerBuf = strToBuf(JSON.stringify(header));
        const headerLen = new Uint32Array([headerBuf.byteLength]);
        const payload = concatBuffers([headerLen.buffer, headerBuf, buf]);

        const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, payload);
        const finalBuffer = concatBuffers([salt.buffer, iv.buffer, encrypted]);

        const record = {
          name: file.name,
          size: file.size,
          type: file.type || "application/octet-stream",
          date: Date.now(),
          salt: Array.from(salt),
          iv: Array.from(iv),
          data: finalBuffer
        };

        await new Promise((res, rej) => {
          const r = store.add(record);
          r.onsuccess = () => res();
          r.onerror = e => rej(e.target.error);
        });
        done++;
      }
      await tx.complete;
      setStatus(statusVault, "Fichiers ajout√©s au coffre.", "success");
      setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      await refreshVaultList();
    }

    async function refreshVaultList() {
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE, "readonly");
      const store = tx.objectStore(VAULT_STORE);
      const index = store.index("by_date");
      vaultItems = [];
      await new Promise((res, rej) => {
        const req = index.openCursor();
        req.onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) { vaultItems.push(cursor.value); cursor.continue(); }
          else res();
        };
        req.onerror = e => rej(e.target.error);
      });
      renderVaultList();
    }

    function renderVaultList() {
      vaultList.innerHTML = "";
      let items = [...vaultItems];
      const q = vaultSearch.value.trim().toLowerCase();
      if (q) items = items.filter(i => i.name.toLowerCase().includes(q));

      const sort = vaultSort.value;
      items.sort((a,b) => {
        if (sort === "date_desc") return b.date - a.date;
        if (sort === "date_asc") return a.date - b.date;
        if (sort === "name_asc") return a.name.localeCompare(b.name);
        if (sort === "name_desc") return b.name.localeCompare(a.name);
        return 0;
      });

      if (!items.length) {
        vaultEmpty.classList.remove("hidden");
        vaultList.appendChild(vaultEmpty);
        return;
      }
      vaultEmpty.classList.add("hidden");

      for (const item of items) {
        const el = document.createElement("div");
        el.className = "vault-item";
        el.dataset.id = item.id;
        if (item.id === vaultSelectedId) el.classList.add("selected");

        const header = document.createElement("div");
        header.className = "vault-item-header";
        const nameEl = document.createElement("div");
        nameEl.className = "vault-item-name";
        nameEl.textContent = item.name;
        const sizeEl = document.createElement("div");
        sizeEl.textContent = formatBytes(item.size);
        header.appendChild(nameEl);
        header.appendChild(sizeEl);

        const meta = document.createElement("div");
        meta.className = "vault-item-meta";
        meta.textContent = new Date(item.date).toLocaleString() + " ‚Ä¢ " + (item.type || "application/octet-stream");

        const actions = document.createElement("div");
        actions.className = "vault-item-actions";

        const btnPreview = document.createElement("button");
        btnPreview.className = "btn btn-ghost";
        btnPreview.textContent = "Aper√ßu";
        btnPreview.addEventListener("click", e => {
          e.stopPropagation();
          selectVaultItem(item);
          previewVaultItem(item);
        });

        const btnRestore = document.createElement("button");
        btnRestore.className = "btn btn-primary";
        btnRestore.textContent = "Restaurer";
        btnRestore.addEventListener("click", e => {
          e.stopPropagation();
          selectVaultItem(item);
          restoreVaultItem(item);
        });

        const btnDelete = document.createElement("button");
        btnDelete.className = "btn btn-danger";
        btnDelete.textContent = "Supprimer";
        btnDelete.addEventListener("click", async e => {
          e.stopPropagation();
          await deleteVaultItem(item.id);
          await refreshVaultList();
        });

        actions.appendChild(btnPreview);
        actions.appendChild(btnRestore);
        actions.appendChild(btnDelete);

        el.appendChild(header);
        el.appendChild(meta);
        el.appendChild(actions);

        el.addEventListener("click", () => selectVaultItem(item));
        vaultList.appendChild(el);
      }
    }

    vaultSearch.addEventListener("input", renderVaultList);
    vaultSort.addEventListener("change", renderVaultList);

    function selectVaultItem(item) {
      vaultSelectedId = item.id;
      metaVaultName.textContent = item.name;
      metaVaultSize.textContent = formatBytes(item.size);
      metaVaultDate.textContent = new Date(item.date).toLocaleString();
      document.querySelectorAll(".vault-item").forEach(el => {
        el.classList.toggle("selected", Number(el.dataset.id) === item.id);
      });
    }

    async function decryptVaultRecord(record) {
      const key = await getVaultMasterKey();
      const salt = new Uint8Array(record.salt);
      const iv = new Uint8Array(record.iv);
      const encryptedBuffer = record.data;
      const cipherData = encryptedBuffer.slice(28);

      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherData);
      const view = new DataView(decrypted);
      const headerLen = view.getUint32(0, true);
      const headerBuf = decrypted.slice(4, 4 + headerLen);
      const dataBuf = decrypted.slice(4 + headerLen);
      const header = JSON.parse(bufToStr(headerBuf));
      return { dataBuffer: dataBuf, header };
    }

    async function previewVaultItem(record) {
      try {
        setProgress(progressVault, progressLabelVault, progressPercentVault, 40, "D√©chiffrement‚Ä¶");
        const { dataBuffer, header } = await decryptVaultRecord(record);
        const meta = header.meta || {};
        const type = meta.type || record.type || "application/octet-stream";
        const blob = new Blob([dataBuffer], { type });
        const url = URL.createObjectURL(blob);

        vaultPreview.innerHTML = "";
        let content;
        if (type.startsWith("image/")) {
          content = document.createElement("img");
          content.src = url;
        } else if (type.startsWith("video/")) {
          content = document.createElement("video");
          content.src = url; content.controls = true;
        } else if (type === "application/pdf") {
          content = document.createElement("iframe");
          content.src = url; content.style.width = "100%"; content.style.height = "200px";
        } else if (type.startsWith("text/") || type === "application/json") {
          const text = await blob.text();
          content = document.createElement("pre");
          content.textContent = text.slice(0, 4000);
        } else {
          content = document.createElement("div");
          content.className = "preview-placeholder";
          content.textContent = "Type non pr√©visualisable ici. Utilise ‚ÄúRestaurer‚Äù pour le t√©l√©charger.";
        }
        vaultPreview.appendChild(content);
        setStatus(statusVault, "Aper√ßu g√©n√©r√©.", "success");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      } catch (e) {
        console.error(e);
        setStatus(statusVault, "Impossible de d√©chiffrer pour aper√ßu (mot de passe ma√Ætre ?).", "error");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      }
    }

    async function restoreVaultItem(record) {
      try {
        setProgress(progressVault, progressLabelVault, progressPercentVault, 40, "D√©chiffrement‚Ä¶");
        const { dataBuffer, header } = await decryptVaultRecord(record);
        const meta = header.meta || {};
        const name = meta.name || record.name;
        const type = meta.type || record.type || "application/octet-stream";
        const blob = new Blob([dataBuffer], { type });

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = name;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);

        setStatus(statusVault, "Fichier restaur√© et t√©l√©charg√©.", "success");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 100, "Termin√©");
      } catch (e) {
        console.error(e);
        setStatus(statusVault, "Impossible de d√©chiffrer pour restauration.", "error");
        setProgress(progressVault, progressLabelVault, progressPercentVault, 0, "En attente‚Ä¶");
      }
    }

    async function deleteVaultItem(id) {
      const db = await getVaultDB();
      const tx = db.transaction(VAULT_STORE, "readwrite");
      const store = tx.objectStore(VAULT_STORE);
      await new Promise((res, rej) => {
        const r = store.delete(id);
        r.onsuccess = () => res();
        r.onerror = e => rej(e.target.error);
      });
      await tx.complete;
      if (vaultSelectedId === id) resetVaultUI();
      setStatus(statusVault, "Fichier supprim√© du coffre.", "success");
    }

    // Init
    showTab("encrypt");
  </script>
</body>
</html>
